import "util.scrypt";

/**
 * AdvancedTokenSale
 *
 * Demonstrates atomic swapping of tokens for satoshis: sales made to a buyer's (public key)
 * Uses TxAdvanced, with external funding (additional input) and a change output
 *
 * Use with: getFundedSighashPreimage() and unlockFundedScriptTx()
 */
contract AdvancedTokenSale {
    // satoshis / token
    int price;

    constructor(int price) {
        this.price = price;
    }

    public function buy(bytes sighashPreimage, bytes changePKH, int changeSats, bytes buyer, int numTokens) {
        // The following arguments can be generated using sample code at
        // https://gist.github.com/scrypt-sv/f6882be580780a88984cee75dd1564c4.js
        PrivKey privKey = PrivKey(0x621de38d9af72be8585d19584e3954d3fd0dc9752bb9f9fb28c4f9ed7c1e40ea);
        PubKey pubKey = PubKey(b'02773aca113a3217b67a95d5b78b69bb6386ed443ea5decf0ba92c00d179291921');
        // invK is the modular inverse of k, the ephemeral key
        int invK = 0xa2103f96554aba49bbf581738d3b5a38c5a44b6238ffb54cfcca65b8c87ddc08;
        // r is x coordinate of R, which is kG
        int r = 0x00f0fc43da25095812fcddde7d7cd353990c62b078e1493dc603961af25dfc6b60;
        // rBigEndian is the signed magnitude representation of r, in big endian
        bytes rBigEndian = b'00f0fc43da25095812fcddde7d7cd353990c62b078e1493dc603961af25dfc6b60';

        // SIGHASH_ANYONECANPAY | SIGHASH_ALL | SIGHASH_FORKID
        bytes sigHashType = b'c1';

        TxAdvanced tx = new TxAdvanced();
        // this ensures the preimage is for the current tx
        require(tx.validate(sighashPreimage, privKey, pubKey, invK, r, rBigEndian, sigHashType));

        // we're using only one byte for the number of tokens purchased
        require( 0 < numTokens && numTokens < 128 );

        int len = length(sighashPreimage);
        bytes hashOutputs = sighashPreimage[len - 40 : len - 8];
        // scriptCode is just scriptPubKey if there is no CODESEPARATOR in the latter
        bytes scriptCode = Util.readVarint(sighashPreimage[104:]);
        int scriptLen = length(scriptCode);

        int balanceStart = 104 /* scriptCode offset */ + 3 /* VarInt encoding */ + scriptLen;
        int oldBalance = Util.fromLEUnsigned(sighashPreimage[balanceStart : balanceStart + 8]);
        int newBalance = oldBalance + numTokens * this.price;

        // data after the OP_RETURN is a growing list of sales entries:
        //     PubKeyA,numTokensPurchased
        //     PubKeyB,numTokensPurchased
        bytes newSalesEntry = buyer ++ num2bin(numTokens, 1);

        // expect the latest sales entry to be appended to the previous script/state
        bytes scriptCode_ = scriptCode ++ Util.writeVarint(newSalesEntry);

        // output: amount + scriptlen + script
        bytes counterOutput = num2bin(newBalance, 8) ++ Util.writeVarint(scriptCode_);

        // Expect the additional CHANGE output
        //    P2PKH:       DUP,HASH160  PKHLen      PKH      EQUALVERIFY,CHECKSIG
        bytes changeScript = b'76a9' ++ b'14' ++  changePKH ++ b'88ac';

        // output: amount + scriptlen + script
        bytes changeOutput = num2bin(changeSats, 8) ++ Util.writeVarint(changeScript);

        // expect exactly two outputs
        Sha256 hashOutputs_ = hash256(counterOutput ++ changeOutput);

        // ensure output matches what we expect:
        //     - amount/balance reflects funds received from sale
        //     - output script is the same as scriptCode, with additional sales entry
        //     - expected change output script is there
        require(hashOutputs == hashOutputs_);
    }
}
